# Phase 1.1: REST API Analysis & Standardization - Research

**Researched:** 2026-02-26
**Domain:** REST API design, OpenAPI 3.0, HTTP semantics, Next.js App Router route handlers
**Confidence:** HIGH (codebase inspected directly; REST standards verified from official sources)

---

## Summary

Mission Control has 28 REST API endpoints across 12 domains, implemented as Next.js App Router route handlers. The API serves two distinct client populations: **internal agents** (autonomous AI processes using API key auth) and **internal UI** (the Next.js frontend calling its own backend). There is no external third-party consumer yet, which gives the team significant latitude to standardize without backward-compatibility risk.

The current API sits at **Richardson Maturity Level 2** overall, with inconsistencies that push several endpoints toward Level 0-1 behavior. Key problems: the gateway endpoint uses query-param action discrimination (`?action=sessions`) instead of resource-based sub-routes; authentication leaks through non-standard headers (`agentId`/`agentKey` in headers rather than `Authorization: Bearer`); error response shapes are inconsistently applied across domains; and the existing OpenAPI spec is hand-crafted in a 1300+ line generator file that will immediately diverge from reality.

The primary recommendation is: **adopt Zod-to-OpenAPI as the single source of truth** — existing Zod schemas in `lib/validators/` should drive both runtime validation and the OpenAPI spec, eliminating the manual generator. Alongside this, two targeted refactors address the highest-severity violations: standardize auth headers to `Authorization: Bearer`, and decompose the gateway action-param anti-pattern into proper sub-routes.

**Primary recommendation:** Use `zod-openapi` (already in `package.json` at v5.4.6) to auto-generate the OpenAPI spec from existing Zod validators, standardize auth to `Authorization: Bearer`, and decompose the gateway action-param pattern into resource-based sub-routes. Do not pursue HATEOAS (Level 3) — Level 2 is the industry standard for APIs of this type.

---

## Current API Surface (Audit)

### Endpoint Inventory (28 endpoints)

| Domain | Path | Methods | Notes |
|--------|------|---------|-------|
| Health | `/api/health` | GET | Clean, no auth |
| OpenAPI | `/api/openapi` | GET | Manual generator, 1300+ lines |
| Agents | `/api/agents` | GET, POST | GET requires `agentId`/`agentKey` headers (non-standard) |
| Agents | `/api/agents/[agentId]` | GET, PATCH | Mixed auth: header vs `Authorization: Bearer` |
| Agents | `/api/agents/[agentId]/tasks` | GET | Auth via query param `agentKey` (not header) |
| Agents | `/api/agents/[agentId]/tasks/[taskId]` | GET, PATCH | PATCH uses action discriminator in body |
| Agents | `/api/agents/[agentId]/tasks/[taskId]/comments` | GET, POST | |
| Agents | `/api/agents/[agentId]/heartbeat` | POST | Correct; idempotent |
| Agents | `/api/agents/[agentId]/poll` | POST | Auth via body (not header) |
| Agents | `/api/agents/[agentId]/rotate-key` | POST | Good: Bearer or body apiKey |
| Agents | `/api/agents/[agentId]/wiki/pages` | GET, POST | |
| Agents | `/api/agents/[agentId]/wiki/pages/[pageId]` | GET, PUT, DELETE | |
| Agents | `/api/agents/workspace/structure` | GET | |
| Tasks | `/api/tasks/[taskId]` | PATCH | 8 actions via discriminator field — anti-pattern |
| Tasks | `/api/tasks/execute` | GET, POST | Non-resource name; GET polls status |
| Tasks | `/api/tasks/generate-daily` | POST | Non-resource name; RPC-style |
| Tasks | `/api/tasks/[taskId]/calendar-events` | GET | |
| Businesses | `/api/businesses` | GET, POST | No auth; `businesses` is alias for workspaces |
| Epics | `/api/epics` | GET | `workspaceId` in query param |
| Calendar | `/api/calendar/events` | GET, POST | POST needs Idempotency-Key |
| Calendar | `/api/calendar/events/[eventId]` | GET, PUT, DELETE | |
| Calendar | `/api/calendar/slots` | GET | |
| Memory | `/api/memory` | GET | Reads local filesystem |
| Memory | `/api/memory/files` | GET | |
| Memory | `/api/memory/context` | GET | |
| Gateway | `/api/gateway/[gatewayId]` | GET, POST | Anti-pattern: 7 sub-operations via `?action=` param |
| State Engine | `/api/state-engine/metrics` | GET | |
| State Engine | `/api/state-engine/decisions` | GET, POST | |
| State Engine | `/api/state-engine/alerts` | GET | |
| Reports | `/api/reports` | GET, POST | |
| Admin | `/api/admin/agents/setup-workspace` | POST | No auth guard |
| Admin | `/api/admin/migrations/agent-workspace-paths` | POST | No auth guard |

---

## Standard Stack

### Core (Already Installed)

| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| `zod` | ^4.3.6 | Schema definition + runtime validation | Already used in all validators; canonical TypeScript validation library |
| `zod-openapi` | ^5.4.6 | Zod-to-OpenAPI schema conversion | Already in package.json; eliminates manual spec authoring |
| `swagger-ui-react` | ^5.31.1 | Swagger UI rendering | Already used in `/api-docs` page |
| `next` | ^15.1.6 | App Router route handlers | Existing framework |

### Supporting (Additive)

| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| `@asteasolutions/zod-to-openapi` | ^7.x | Alternative Zod-to-OpenAPI bridge with route registration | If `zod-openapi` lacks registry pattern needed |
| `vitest` | — | Unit testing if Jest migration desired | Not needed now; Jest is working |

### Alternatives Considered

| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| `zod-openapi` | `next-openapi-gen` (JSDoc-based) | JSDoc generation is fragile; Zod schema approach ties validation to documentation as single source of truth |
| Manual OpenAPI generator | `swagger-jsdoc` | JSDoc approach diverges from code over time; Zod schemas are already the validation truth |
| URL path versioning | Header versioning | For this codebase (internal consumers only, no public API), versioning is not yet needed. When needed, URL path (`/api/v1/...`) is simpler to cache and test |

**Installation:** No new packages required. `zod-openapi` is already installed.

---

## Architecture Patterns

### Richardson Maturity Model — Current State vs. Target

| Endpoint Group | Current Level | Target Level | Gap |
|---------------|--------------|-------------|-----|
| `/api/health` | Level 2 | Level 2 | None |
| `/api/agents/**` | Level 1-2 | Level 2 | Auth header standardization |
| `/api/tasks/[taskId]` | Level 1 | Level 2 | Action discriminator → separate sub-resources |
| `/api/gateway/[gatewayId]` | Level 0 | Level 2 | `?action=` anti-pattern → sub-routes |
| `/api/tasks/execute` | Level 0 | Level 2 | RPC-style name → resource-based |
| `/api/businesses` | Level 2 | Level 2 | Naming convention (alias issue) |

**Target: Level 2 (not Level 3)**. HATEOAS (Level 3) is not recommended for this domain. Agent clients are autonomous processes that know their API from a spec, not a browser navigating links. Level 3 adds complexity without benefit for machine-to-machine APIs. The [Richardson Maturity Model](https://martinfowler.com/articles/richardsonMaturityModel.html) explicitly notes Level 3 is rarely seen in production.

### Recommended Project Structure (No Change Required)

```
frontend/src/app/api/
├── agents/
│   ├── route.ts                          # GET list, POST register
│   └── [agentId]/
│       ├── route.ts                      # GET details, PATCH update
│       ├── heartbeat/route.ts            # POST heartbeat
│       ├── poll/route.ts                 # POST poll
│       ├── rotate-key/route.ts           # POST rotate key
│       ├── tasks/
│       │   ├── route.ts                  # GET list tasks
│       │   └── [taskId]/
│       │       ├── route.ts              # GET task, PATCH task
│       │       └── comments/route.ts     # GET/POST comments
│       └── wiki/
│           └── pages/
│               ├── route.ts              # GET/POST pages
│               └── [pageId]/route.ts     # GET/PUT/DELETE page
├── gateway/
│   └── [gatewayId]/
│       ├── route.ts                      # GET status (replaces ?action=status)
│       ├── sessions/route.ts             # GET sessions (replaces ?action=sessions)
│       ├── messages/route.ts             # POST message (replaces ?action=message)
│       ├── history/route.ts              # GET history (replaces ?action=history)
│       ├── provision/route.ts            # POST provision (replaces ?action=provision)
│       ├── sync/route.ts                 # POST sync (replaces ?action=sync)
│       └── validate/route.ts             # POST validate (replaces ?action=validate)
├── tasks/
│   ├── executions/route.ts               # POST create execution (replaces /execute)
│   ├── executions/[executionId]/route.ts # GET execution status
│   ├── [taskId]/
│   │   ├── route.ts                      # PATCH (kept, action discriminator acceptable here)
│   │   ├── assignments/route.ts          # POST assign (alternative to discriminator)
│   │   └── calendar-events/route.ts      # GET
│   └── daily-batches/route.ts            # POST generate (replaces /generate-daily)
└── ...
```

### Pattern 1: Zod Schema as OpenAPI Source of Truth

**What:** Annotate existing Zod schemas with OpenAPI metadata using `zod-openapi`. The OpenAPI spec is generated from the schemas, not hand-authored.

**When to use:** Always, for all route handlers that accept or return structured data.

**Example:**
```typescript
// Source: zod-openapi v5 docs (package already installed)
import { z } from "zod";
import { extendZodWithOpenApi } from "zod-openapi";

extendZodWithOpenApi(z);

export const AgentSchema = z.object({
  id: z.string().openapi({ example: "j571bde7r1xhka72yp3p66bx8k6wm3yn" }),
  name: z.string().min(2).max(50).openapi({ example: "Atlas" }),
  role: z.string().openapi({ example: "Backend Engineer" }),
  level: z.enum(["lead", "specialist", "intern"]).openapi({ example: "lead" }),
  status: z.enum(["active", "idle", "blocked"]).openapi({ example: "active" }),
}).openapi("Agent");

// In the route handler:
export const RegisterAgentRequestSchema = z.object({
  name: z.string().min(2).max(50),
  role: z.string(),
  level: z.enum(["lead", "specialist", "intern"]),
  sessionKey: z.string(),
  workspacePath: z.string(),
}).openapi("RegisterAgentRequest");
```

### Pattern 2: Standardized Auth — `Authorization: Bearer`

**What:** Replace all non-standard auth mechanisms (`agentId`/`agentKey` headers, `agentKey` query params, `apiKey` in body) with standard `Authorization: Bearer <key>`. The `agentId` moves to the URL path (it is already there for most endpoints).

**Why:** RFC 6750 defines `Authorization: Bearer` as the standard. Current pattern uses custom header names (`agentId`, `agentKey`) which are non-standard HTTP headers and confuse API tooling, caching, and security scanners.

**Current (non-standard):**
```typescript
// GET /api/agents — requires agentId AND agentKey headers
const agentId = request.headers.get("agentId");   // non-standard
const agentKey = request.headers.get("agentKey"); // non-standard
```

**Target (standard):**
```typescript
// GET /api/agents — requires Authorization: Bearer <key>
// Agent ID already in URL path for per-agent endpoints
const authHeader = request.headers.get("Authorization");
if (!authHeader?.startsWith("Bearer ")) { ... }
const agentKey = authHeader.slice(7);
// For /api/agents list: agent identity from the Bearer token itself
```

### Pattern 3: Consistent Error Response Shape

**What:** All error responses must use the `ApiErrorResponse` shape from `lib/utils/apiResponse.ts`. Never use `{ error: "string" }` raw form.

**Current situation:** Three error shapes exist in the codebase:

Shape A (standardized — correct):
```json
{ "success": false, "error": { "code": "NOT_FOUND", "message": "Agent not found" }, "timestamp": 1234567890 }
```

Shape B (raw — found in gateway, memory, reports routes):
```json
{ "error": "Gateway not found" }
```

Shape C (mixed — found in businesses route):
```json
{ "success": false, "error": "error message string" }
```

**Target:** Shape A everywhere. The `handleApiError()` utility already does this correctly — it is simply not used consistently.

### Pattern 4: Error Response — RFC 9457 Consideration

RFC 9457 (Problem Details for HTTP APIs, successor to RFC 7807) defines a standard schema for error bodies with `type`, `title`, `status`, `detail`, and `instance` fields.

**Decision for this codebase:** Do NOT migrate to RFC 9457 format. Reasons:
1. The existing `{ success, error: { code, message, details } }` shape is already well-typed and used throughout the codebase
2. Agent clients would need to be updated to parse a different format
3. The `code` field provides machine-readable error discrimination comparable to RFC 9457's `type`
4. Adding RFC 9457 would be a breaking change with no functional benefit for internal consumers

Document the current schema in OpenAPI `components/schemas/ErrorResponse` and treat it as the standard.

### Pattern 5: Pagination Consistency

**What:** All list endpoints use `limit` + `offset` pagination with a consistent `meta` response shape.

**Current state:** Only one endpoint implements pagination (`GET /api/agents/[agentId]/tasks`). Others return unbounded lists.

**Target standard:**
```typescript
// Query params
// ?limit=50&offset=0

// Response
{
  "success": true,
  "data": {
    "items": [...],
    "meta": {
      "total": 150,     // total count (if cheap to compute)
      "limit": 50,
      "offset": 0,
      "hasMore": true
    }
  }
}
```

**Pagination strategy choice:** Offset-based (`limit` + `offset`) is appropriate for this codebase. Cursor-based pagination is superior for large, rapidly changing datasets (social feeds), but Mission Control's task/agent lists are small (<10,000 records), operator-driven, and typically filtered. The performance argument for cursor pagination does not apply at this scale.

**Exception:** Convex's native pagination API uses cursors internally. When wrapping Convex queries with `.paginate()`, use Convex's own cursor. Do not attempt to translate Convex cursors to offset-based for the API response — simply pass `numItems` and expose the Convex-style pagination.

### Anti-Patterns to Avoid

- **Action discriminator in query params:** `?action=sessions` on the same URL as `?action=history` — these are different resources and should be different URLs. The gateway route is the only current offender.
- **Auth via query params:** `?agentKey=xxx` exposes credentials in server logs, browser history, and proxy caches. Always use headers.
- **Auth via request body:** `{ "apiKey": "..." }` in request body requires parsing body before auth check — auth must use headers.
- **Mixed response shapes:** Some routes return `Response.json(...)` (no `success` field) while others use `jsonResponse(successResponse(...))`. All routes must use the `jsonResponse(successResponse(...))` utility.
- **Inline `jsonResponse` clones:** The `epics/route.ts` defines its own local `jsonResponse` function instead of importing from `lib/utils/apiResponse`. This creates divergence.
- **RPC-style endpoint names:** `/tasks/execute`, `/tasks/generate-daily` — these are verbs, not nouns. REST resources are nouns (`/tasks/executions`, `/tasks/daily-batches`).
- **Swallowing JSON parse errors:** `request.json().catch(() => ({}))` silently continues with empty body — should return 400.

---

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| OpenAPI spec | Manual 1300-line generator (`lib/openapi-generator.ts`) | `zod-openapi` v5.4.6 (already installed) | Already installed; Zod schemas are the validation source of truth; spec stays in sync automatically |
| Auth middleware | Per-route inline `verifyAgent()` chains | Extract to shared `withAgentAuth(handler)` wrapper | Reduces duplication across 15+ routes; ensures consistent 401 format |
| Request ID tracking | Per-route `crypto.randomUUID()` | Centralized middleware in Next.js `middleware.ts` | Ensures X-Request-Id on ALL responses, including 404s from Next.js itself |
| Error shape normalization | Per-route `handleApiError` | Already built — just use it consistently | `lib/utils/apiResponse.ts` already has `handleApiError`; 6 routes bypass it |
| Pagination | Ad-hoc limit/offset parsing | Shared `parsePagination(searchParams)` utility | Ensures consistent defaults (limit=50, max=200) and error messages |

**Key insight:** The `lib/utils/apiResponse.ts` and `lib/validators/` modules are well-designed but inconsistently applied. Phase 1.1 should enforce usage of existing patterns, not build new ones.

---

## Common Pitfalls

### Pitfall 1: OpenAPI Spec Divergence

**What goes wrong:** Hand-authored OpenAPI specs immediately fall behind the implementation. The existing `lib/openapi-generator.ts` (1300+ lines) defines schemas that may not match the actual Zod validators or route behavior.

**Why it happens:** There is no automated link between the Zod schemas (runtime truth) and the OpenAPI spec (documentation truth). They are edited independently.

**How to avoid:** Use `zod-openapi` to register schemas once. The spec is generated from the same Zod object used for validation. No two places to update.

**Warning signs:** Check whether `generateOpenAPISpec()` in `lib/openapi-generator.ts` references field names that differ from `lib/validators/agentValidators.ts`. Any divergence is a documentation bug.

### Pitfall 2: Auth Inconsistency Breaks Agent Clients

**What goes wrong:** If auth is changed from custom headers to `Authorization: Bearer` without updating agent clients simultaneously, all agent API calls break.

**Why it happens:** Auth refactors affect all callers, which in an agent system may be autonomous processes running in separate terminal sessions.

**How to avoid:** This is a **breaking change**. The audit report should flag it as such. The refactoring roadmap must specify: (a) a grace period where both old and new auth methods are accepted, or (b) a coordinated cutover where agent registration is updated first.

**Warning signs:** Any endpoint that reads `request.headers.get("agentId")` or `request.headers.get("agentKey")` needs migration.

### Pitfall 3: Gateway Route Decomposition Breaks Existing Tests

**What goes wrong:** `src/app/api/gateway/[gatewayId]/__tests__/sessions.test.ts` and `provision.test.ts` test the `?action=` pattern. Decomposing to sub-routes requires rewriting these 70+ tests.

**Why it happens:** Tests mock the single route file. New route files are separate modules.

**How to avoid:** The gateway refactor is a breaking change for tests. Plan the test migration as part of the implementation task, not as a follow-up. Do not count the refactor as done until tests are green on the new sub-route structure.

**Warning signs:** Any test file that constructs URLs with `?action=` parameter.

### Pitfall 4: Pagination Breaks Existing Agent Queries

**What goes wrong:** Adding `meta.total` to list responses requires counting queries. Convex does not have cheap `COUNT(*)`. Adding count may require a separate query that adds latency.

**Why it happens:** SQL databases count cheaply; Convex requires iterating or maintaining a denormalized count.

**How to avoid:** For Convex-backed lists, omit `meta.total` and instead use `meta.hasMore` (derivable from `results.length > limit`). Document this as intentional in the OpenAPI spec.

**Warning signs:** Any endpoint that wraps a Convex `query.collect()` for pagination — check whether count is being computed.

### Pitfall 5: Versioning Strategy Paralysis

**What goes wrong:** Teams over-engineer versioning before they have external consumers, adding `/api/v1/` prefixes everywhere, creating maintenance burden for no current benefit.

**Why it happens:** Versioning feels like the responsible thing to do pre-launch.

**How to avoid:** Do not add URL versioning (`/api/v1/`) now. Mission Control has zero external consumers. Versioning should be introduced only when a breaking change is needed AND there is a consumer that cannot update immediately. The audit report should note this as a deferred decision, not a current action.

**Warning signs:** If someone proposes adding `/v1/` to all routes in Phase 1.1, challenge: "Who are the callers we cannot update simultaneously?" If the answer is "nobody yet," defer versioning.

### Pitfall 6: The `?action=` Anti-Pattern Re-emerges

**What goes wrong:** Future developers add new capabilities to the gateway endpoint by adding more action values to the existing single route, because that pattern is already established.

**Why it happens:** The first engineer creates the pattern; subsequent engineers follow it.

**How to avoid:** Fix the gateway pattern in Phase 1.1 (or explicitly mark it as a Phase 1.1 recommendation). If it is not fixed, document it as technical debt in the audit report with a clear recommendation.

---

## Code Examples

### Correct Auth Header Pattern

```typescript
// Source: RFC 6750; observed in rotate-key/route.ts (already correct)
export async function POST(request: Request, context: any): Promise<Response> {
  const agentId = context.params.agentId;

  // CORRECT: Authorization: Bearer <key>
  const authHeader = request.headers.get("Authorization");
  if (!authHeader?.startsWith("Bearer ")) {
    return jsonResponse(
      { success: false, error: { code: "UNAUTHORIZED", message: "Authorization: Bearer <key> required" } },
      401
    );
  }
  const agentKey = authHeader.slice(7);
  // ... proceed
}
```

### Consistent Error Response

```typescript
// Source: lib/utils/apiResponse.ts — use this everywhere
import { jsonResponse, handleApiError, UnauthorizedError, NotFoundError } from "@/lib/utils/apiResponse";

// These must NEVER appear in route handlers:
// return new Response(JSON.stringify({ error: "string" }), { status: 404 })
// return Response.json({ success: false, error: "string" }, { status: 400 })
```

### Pagination Response Shape

```typescript
// Standard shape for list endpoints
return jsonResponse(
  successResponse({
    items: tasks,
    meta: {
      limit: limit,
      offset: offset,
      hasMore: tasks.length === limit,
      // total: OMIT for Convex-backed endpoints (count is expensive)
    },
  })
);
```

### zod-openapi Schema Extension

```typescript
// Source: zod-openapi package docs (already installed at ^5.4.6)
import { z } from "zod";
import { extendZodWithOpenApi } from "zod-openapi";

extendZodWithOpenApi(z);

// Extend existing validator — additive change, no breaking behavior
export const RegisterAgentSchema = z.object({
  name: z.string().min(2).max(50),
  role: z.string(),
  level: z.enum(["lead", "specialist", "intern"]),
  sessionKey: z.string(),
  workspacePath: z.string(),
}).openapi({
  ref: "RegisterAgentRequest",
  example: {
    name: "Atlas",
    role: "Backend Engineer",
    level: "lead",
    sessionKey: "sess_abc123",
    workspacePath: "/workspace/atlas",
  },
});
```

---

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Hand-authored OpenAPI YAML | Code-first from types/validators | 2023-present | Spec stays in sync with code |
| Swagger 2.0 | OpenAPI 3.0 / 3.1 | OpenAPI 3.0: 2017, 3.1: 2021 | Better schema support, webhooks |
| RFC 7807 Problem Details | RFC 9457 (successor) | 2023 | Minor additions; 7807 still widely used |
| Offset pagination everywhere | Cursor pagination for large datasets | 2019-present | Cursor only for high-velocity, large datasets |
| Username/password in headers | Bearer token (`Authorization: Bearer`) | RFC 6750, 2012 | Standard across all modern APIs |

**Deprecated/outdated:**
- Custom header auth (`agentId`, `agentKey` as header names): Non-standard, not recognized by OpenAPI tooling security schemes, breaks API gateway auth plugins
- `?action=` query param routing: Collapses distinct resources into one URL, makes caching and rate-limiting impossible at the HTTP layer
- Manual OpenAPI spec generators with hard-coded JSON structures: Impossible to keep in sync; generates false documentation

---

## RESTful Compliance Matrix

Assessment of each endpoint group against 6 REST dimensions:

| Endpoint Group | HTTP Verbs | Resource Naming | Statelessness | Response Codes | Auth Standard | Severity |
|---------------|-----------|-----------------|--------------|----------------|---------------|----------|
| `/api/health` | PASS | PASS | PASS | PASS | N/A | None |
| `/api/agents` | PASS (GET/POST) | PASS | PASS | PASS (201 on create) | FAIL (custom headers) | HIGH |
| `/api/agents/[id]` | PASS (GET/PATCH) | PASS | PASS | PASS | FAIL (mixed auth) | HIGH |
| `/api/agents/[id]/tasks` | PASS (GET) | PASS | PASS | PASS | FAIL (auth in query param) | HIGH |
| `/api/tasks/[id]` | PARTIAL (PATCH only, 8 sub-ops) | PASS | PASS | PASS | FAIL (auth in body) | MEDIUM |
| `/api/tasks/execute` | FAIL (verb in name) | FAIL (verb) | PASS | PASS | NONE | HIGH |
| `/api/tasks/generate-daily` | FAIL (verb in name) | FAIL (verb) | PASS | PASS | NONE | HIGH |
| `/api/gateway/[id]` | FAIL (7 ops via ?action=) | FAIL (action param) | PASS | FAIL (raw error shape) | NONE | CRITICAL |
| `/api/businesses` | PASS (GET/POST) | PASS | PASS | PASS | NONE | LOW |
| `/api/calendar/events` | PASS (GET/POST) | PASS | PASS | PASS (201) | PASS (Bearer) | None |
| `/api/memory` | PASS (GET) | PASS | FAIL (reads local filesystem) | PARTIAL | NONE | HIGH |
| `/api/state-engine/*` | PASS | PASS | PASS | FAIL (raw errors) | NONE | MEDIUM |
| `/api/admin/*` | PASS | PASS | PASS | PASS | FAIL (no auth) | CRITICAL |
| `/api/openapi` | PASS (GET) | PASS | PASS | PASS | N/A | None |

---

## OpenAPI 3.0 Specification Best Practices

### Structure Requirements

The OpenAPI spec must:

1. **Use `components/schemas` for all reusable types** — never inline schemas in path definitions
2. **Define `securitySchemes`** — specify `BearerAuth` (http/bearer) as the agent auth scheme
3. **Apply security at operation level** — not all endpoints require agent auth (health, openapi, businesses)
4. **Document all response codes** — minimum: 200/201, 400, 401, 404, 500 for each operation
5. **Include `tags`** — group operations by domain (Agents, Tasks, Gateway, Calendar, Memory, Admin, Health)
6. **Set `servers`** — include both local dev and production server objects

### Spec Generation Strategy

The existing `lib/openapi-generator.ts` (1300+ lines of hand-written JSON) should be **replaced**, not refactored. The replacement uses `zod-openapi`:

1. Annotate existing Zod schemas in `lib/validators/` with `.openapi()` metadata
2. Create a registry (`OpenApiGeneratorV3` from `zod-openapi`) that registers all schemas
3. Register route operations with their schemas
4. Generate the spec at build time or request time

This is an additive change — the Zod schemas themselves are unchanged. `.openapi()` is a decorator that adds metadata without altering validation behavior.

### Key OpenAPI Fields for This Domain

```yaml
# securitySchemes
components:
  securitySchemes:
    BearerAuth:
      type: http
      scheme: bearer
      description: Agent API key issued at registration

# Pagination meta schema (reusable)
components:
  schemas:
    PaginationMeta:
      type: object
      properties:
        limit: { type: integer, example: 50 }
        offset: { type: integer, example: 0 }
        hasMore: { type: boolean, example: false }

    ErrorResponse:
      type: object
      required: [success, error]
      properties:
        success: { type: boolean, enum: [false] }
        error:
          type: object
          required: [code, message]
          properties:
            code: { type: string, example: "NOT_FOUND" }
            message: { type: string, example: "Agent not found" }
            details: { description: "Validation details if applicable" }
        timestamp: { type: integer, format: int64 }
```

---

## Migration Strategies

### Non-Breaking Changes (Safe to Deploy Immediately)

1. **Add `zod-openapi` annotations to existing validators** — purely additive, zero behavior change
2. **Replace `lib/openapi-generator.ts` with spec from `zod-openapi`** — same endpoint at `/api/openapi`, same Swagger UI, different internal generation
3. **Standardize error shape in gateway and memory routes** — add `success` field; change `{ error: "string" }` to `{ success: false, error: { code, message } }` — agent clients that don't check the body structure will not break
4. **Add pagination `meta` to list endpoints that return arrays** — additive field; existing consumers ignore unknown fields
5. **Add `X-Request-Id` header to all responses** — additive header

### Breaking Changes (Require Coordinated Cutover)

1. **Auth header standardization** — changing from `agentId`/`agentKey` headers to `Authorization: Bearer` requires ALL agent clients to update simultaneously, or a grace period where both formats are accepted
2. **Gateway sub-route decomposition** — `?action=sessions` → `/sessions` changes URLs, breaks any client that hardcodes the `?action=` form
3. **Task execute URL** — `/tasks/execute` → `/tasks/executions` is a URL change
4. **Generate-daily URL** — `/tasks/generate-daily` → `/tasks/daily-batches` is a URL change

**Migration pattern for breaking changes:** Accept both old and new form for 2 weeks (grace period), log deprecation warnings, then remove old form. This applies only when autonomous agents are the callers (they run continuously and may not restart immediately).

### Refactoring Roadmap Classification

| Change | Type | Priority | Effort |
|--------|------|---------|--------|
| `zod-openapi` spec generation | Non-breaking | HIGH | Medium (annotate existing schemas) |
| Gateway `?action=` → sub-routes | Breaking | HIGH | Medium (create new files + update tests) |
| Auth header standardization | Breaking | HIGH | Low-Medium (update `verifyAgent` callers) |
| Error shape standardization | Non-breaking | HIGH | Low (6 routes need update) |
| Admin endpoint auth guards | Non-breaking | CRITICAL | Low (add `verifyAgent` calls) |
| Task `execute` URL rename | Breaking | MEDIUM | Low |
| Task `generate-daily` URL rename | Breaking | MEDIUM | Low |
| Pagination standardization | Non-breaking | MEDIUM | Medium (add to 6+ list endpoints) |
| Memory endpoint filesystem → DB | Non-breaking | LOW | High (architecture change) |
| HATEOAS links | Non-breaking | LOW → DEFER | High (no benefit for agent clients) |

---

## Open Questions

1. **Breaking change timing for auth header**
   - What we know: Auth header standardization will break all agent callers using `agentId`/`agentKey` headers
   - What's unclear: Are there long-running agents with hardcoded headers that can't be restarted immediately?
   - Recommendation: Accept both forms during a 2-week grace period. Log deprecation warning when old form is used.

2. **Gateway endpoint — immediate refactor vs. documented debt**
   - What we know: The `?action=` pattern is a Level 0 anti-pattern. 70+ tests cover the current form.
   - What's unclear: Is the gateway refactor in scope for Phase 1.1 (audit report) or Phase 3+ (execution engine)?
   - Recommendation: Phase 1.1 produces the recommendation. The actual refactor happens in Phase 3 when gateway dispatch is redesigned for workflow execution. Documenting it now ensures it's built correctly in Phase 3.

3. **`/api/memory` filesystem dependency**
   - What we know: The memory endpoint reads from `~/.openclaw/workspace/memory` on the local filesystem. This only works in development environments.
   - What's unclear: Is this endpoint intended to be production-ready or is it a dev-only feature?
   - Recommendation: Flag as development-only in the audit report. Do not include in the production OpenAPI spec. Long-term: memory must move to Convex.

4. **`/api/businesses` naming vs. `workspaces`**
   - What we know: The route is `/api/businesses` but internally calls `api.workspaces.*` Convex queries. The UI previously used "businesses" and was relabeled to "workspaces."
   - What's unclear: Should the API URL change to `/api/workspaces` to match the internal model?
   - Recommendation: Flag as an inconsistency. If the change is made, it is non-breaking IF the frontend also updates its API calls. Since both the route and the frontend caller are in the same monorepo, this is a safe rename if done atomically.

---

## Validation Architecture

### Test Framework

| Property | Value |
|----------|-------|
| Framework | Jest 30.x + jest-environment-node |
| Config file | `jest.config.js` (at frontend root) |
| Quick run command | `npm test -- --testPathPattern="src/app/api"` |
| Full suite command | `npm test` |

### Phase Requirements → Test Map

| Req ID | Behavior | Test Type | Automated Command | File Exists? |
|--------|----------|-----------|-------------------|-------------|
| REQ-AUDIT-01 | All 28 endpoints identified with HTTP methods, paths, auth pattern | Manual audit | N/A | ❌ Wave 0: Create audit checklist |
| REQ-AUDIT-02 | RESTful compliance matrix per endpoint | Manual analysis | N/A | ❌ Wave 0: Create matrix document |
| REQ-AUDIT-03 | OpenAPI spec generated from Zod schemas | Unit | `npm test -- --testPathPattern="openapi"` | ❌ Wave 0: Create spec generation test |
| REQ-AUDIT-04 | Standardization recommendations documented | Manual | N/A | ❌ Wave 0: Create recommendations doc |
| REQ-AUDIT-05 | Breaking vs. non-breaking change classification | Manual | N/A | ❌ Wave 0: Part of recommendations doc |

### Wave 0 Gaps

- [ ] `frontend/src/app/api/__tests__/openapi-completeness.test.ts` — verifies all route paths appear in generated spec
- [ ] `frontend/lib/__tests__/openapi-generator.test.ts` — existing test exists but may test the hand-written generator; update to test zod-openapi generation
- [ ] Audit checklist document at `.planning/phases/01.1-rest-api-analysis/AUDIT-CHECKLIST.md`

### Sampling Rate

- **Per task commit:** `npm test -- --testPathPattern="openapi"` (spec generation smoke test)
- **Per wave merge:** `npm test` (full suite)
- **Phase gate:** All tests green + manual validation that `/api/openapi` endpoint returns valid spec

---

## Sources

### Primary (HIGH confidence)

- Richardson Maturity Model — [Martin Fowler](https://martinfowler.com/articles/richardsonMaturityModel.html) — confirms Level 2 as de facto standard; Level 3 (HATEOAS) rarely production-deployed
- RFC 6750 — [Bearer Token Usage](https://datatracker.ietf.org/doc/html/rfc6750) — `Authorization: Bearer` standard
- RFC 9457 — [Problem Details for HTTP APIs](https://www.rfc-editor.org/rfc/rfc9457.html) — updated error response standard (successor to RFC 7807)
- `zod-openapi` package — already in `frontend/package.json` at `^5.4.6` — confirmed installed
- Direct codebase inspection of all 28 route handler files in `frontend/src/app/api/`
- `lib/utils/apiResponse.ts` — existing standardized error/response utilities
- `lib/validators/agentValidators.ts`, `agentTaskValidators.ts`, `taskValidators.ts` — existing Zod schemas

### Secondary (MEDIUM confidence)

- [Cursor vs. offset pagination comparison](https://www.speakeasy.com/api-design/pagination) — cursor pagination superior for large/volatile datasets; offset appropriate for small bounded datasets
- [API Versioning Best Practices 2025](https://www.gravitee.io/blog/api-versioning-best-practices) — URL path versioning preferred for public APIs; no versioning needed pre-launch for internal APIs
- [URL vs. Header auth in APIs](https://www.lonti.com/blog/api-versioning-url-vs-header-vs-media-type-versioning) — query param auth exposes credentials in logs; headers required

### Tertiary (LOW confidence — require validation)

- Specific `zod-openapi` v5 API for registry pattern — version changed from v4 to v5 in 2024; verify `.openapi()` method signatures match installed version before implementation

---

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH — packages confirmed in `package.json`; Zod and `zod-openapi` already installed
- Architecture: HIGH — all 28 route files read directly; patterns confirmed from source
- Pitfalls: HIGH — identified from direct codebase inspection and RFC sources
- REST principles: HIGH — Richardson Maturity Model and RFC standards are stable, well-documented

**Research date:** 2026-02-26
**Valid until:** 2026-04-26 (60 days — REST standards are stable; `zod-openapi` API may change on major version bump)
