---
phase: 02-workspace-isolation-rbac
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - backend/convex/schema.ts
  - backend/convex/organizationMembers.ts
  - backend/convex/migrations.ts
  - backend/convex/__tests__/organizationMembers.test.ts
autonomous: true
requirements:
  - WS-05
  - WS-02

must_haves:
  truths:
    - "ROLE_LEVELS constant defines admin=4, agent=3, collaborator=2, viewer=1"
    - "hasRequiredRole(userRole, requiredRole) returns true when userRole >= requiredRole"
    - "requireRole() throws ConvexError('NOT_FOUND') when user is not a member"
    - "requireRole() throws ConvexError('NOT_FOUND') when role is insufficient (not 403)"
    - "requireRole() passes silently for system admins regardless of workspace membership"
    - "4-level schema union (admin/agent/collaborator/viewer) added as userRole field; after MIG-18 runs, the legacy role field is removed from schema (no coexistence period per locked decision)"
    - "MIG-18 migration converts owner→admin, admin→collaborator, member→viewer in organizationMembers"
    - "Last admin protection: removeMember throws 'Must have at least one admin' when removing last admin"
  artifacts:
    - path: "backend/convex/schema.ts"
      provides: "userRole field (required after migration) in organizationMembers; legacy role field removed post-MIG-18; systemAdmins table"
      contains: "userRole"
    - path: "backend/convex/organizationMembers.ts"
      provides: "ROLE_LEVELS, UserRole type, hasRequiredRole(), requireRole() exports"
      exports: ["ROLE_LEVELS", "UserRole", "hasRequiredRole", "requireRole"]
    - path: "backend/convex/__tests__/organizationMembers.test.ts"
      provides: "Test coverage for role hierarchy, requireRole, migration, last-admin guard"
      min_lines: 80
    - path: "backend/convex/migrations.ts"
      provides: "MIG-18 role hierarchy migration mutation"
      contains: "MIG-18"
  key_links:
    - from: "backend/convex/organizationMembers.ts ROLE_LEVELS"
      to: "requireRole() comparison"
      via: "hasRequiredRole(member.userRole, requiredRole)"
      pattern: "ROLE_LEVELS\\[userRole\\] >= ROLE_LEVELS\\[requiredRole\\]"
    - from: "systemAdmins table lookup"
      to: "requireRole() bypass"
      via: "ctx.db.query('systemAdmins').withIndex('by_user')"
      pattern: "isSystemAdmin.*return"
---

<objective>
TDD implementation of the 4-level RBAC role hierarchy: schema migration + pure Convex logic helpers.

Purpose: Establish the role type system and enforcement helpers that all subsequent plans depend on. TDD ensures the hierarchy logic is correct before it's used across 20+ route handlers.

Output: Schema that starts with both fields optional (to allow migration to run), MIG-18 migration that atomically moves all records from `role` → `userRole` and clears the legacy field in the same patch, then schema updated to remove `role` entirely. `requireRole()` helper and full test coverage.
</objective>

<execution_context>
@/Users/arana/.claude/get-shit-done/workflows/execute-plan.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/phases/02-workspace-isolation-rbac/02-CONTEXT.md
@.planning/phases/02-workspace-isolation-rbac/02-RESEARCH.md

<interfaces>
<!-- Key existing patterns the executor must follow. Do NOT deviate from these. -->

From backend/convex/organizationMembers.ts (existing pattern to EXTEND):
```typescript
// Current 3-role check — extend to 4 roles
const roleHierarchy = { owner: 3, admin: 2, member: 1 };
return roleHierarchy[member.role] >= roleHierarchy[args.requiredRole];

// Existing requireAdmin/requireOwner pattern (to REPLACE with requireRole):
export async function requireAdmin(ctx, workspaceId, userId): Promise<void>
export async function requireOwner(ctx, workspaceId, userId): Promise<void>
```

From backend/convex/schema.ts (current organizationMembers fields):
```typescript
organizationMembers: defineTable({
  workspaceId: convexVal.optional(convexVal.id("workspaces")),
  userId: convexVal.string(),
  role: convexVal.union(
    convexVal.literal("owner"),
    convexVal.literal("admin"),
    convexVal.literal("member")
  ),
  // ... allBoardsRead, allBoardsWrite, etc.
})

invites: defineTable({
  role: convexVal.union(
    convexVal.literal("owner"),
    convexVal.literal("admin"),
    convexVal.literal("member")
  ),
  // ...
})
```

From backend/convex/migrations.ts (next migration ID after MIG-18 verification):
```typescript
// IMPORTANT: MIG-11 through MIG-17 are used per grep of the file.
// The next logical name is MIG-18 for the role hierarchy migration.
// Function name convention: export const migration{Description} = mutation({...})
```

From backend/convex/utils/rateLimit.ts (checkRateLimitSilent signature):
```typescript
export async function checkRateLimitSilent(
  ctx: any,
  key: string,      // e.g., "perm_fail:userId:workspaceId"
  maxCalls: number, // 5
  windowMs: number  // 60_000
): Promise<boolean>
```
</interfaces>
</context>

<tasks>

<task type="tdd">
  <name>Task 1 (RED): Write failing tests for 4-level role hierarchy logic</name>
  <files>backend/convex/__tests__/organizationMembers.test.ts</files>
  <action>
Create test file at `backend/convex/__tests__/organizationMembers.test.ts`. Write tests using Jest that describe the expected behavior BEFORE any implementation exists. Tests MUST fail on first run.

Test cases to write:

**ROLE_LEVELS and hasRequiredRole:**
```typescript
describe('ROLE_LEVELS', () => {
  it('assigns admin=4, agent=3, collaborator=2, viewer=1')
  it('hasRequiredRole: admin satisfies admin requirement')
  it('hasRequiredRole: admin satisfies viewer requirement')
  it('hasRequiredRole: viewer does NOT satisfy admin requirement')
  it('hasRequiredRole: collaborator satisfies collaborator requirement')
  it('hasRequiredRole: agent does NOT satisfy admin requirement')
})
```

**requireRole (mock Convex ctx):**
```typescript
describe('requireRole', () => {
  it('passes silently when member has exact required role')
  it('passes silently when member has higher role')
  it('throws ConvexError("NOT_FOUND") when member not found')
  it('throws ConvexError("NOT_FOUND") when role insufficient')
  it('passes silently for system admin (bypasses membership check)')
  it('passes when system admin not in organizationMembers')
})
```

**Last admin protection:**
```typescript
describe('removeMember', () => {
  it('throws "Must have at least one admin" when removing last admin')
  it('allows removing member when another admin exists')
  it('allows removing non-admin members freely')
})
```

**MIG-18 role mapping:**
```typescript
describe('MIG-18 role migration', () => {
  it('maps owner → admin and clears legacy role field')
  it('maps admin → collaborator and clears legacy role field')
  it('maps member → viewer and clears legacy role field')
  it('maps unknown → viewer (safe default) and clears legacy role field')
  it('is idempotent: skips records that already have userRole set')
  it('migrates ALL records via .collect() (no batchSize arg accepted)')
})
```

Mock the Convex `ctx.db` using Jest mocks. Follow the existing mock pattern from other test files in the project.

Run: `npm test -- --testPathPattern="organizationMembers" 2>&1 | tail -20`

Tests MUST fail (RED phase). Commit: `test(02-01): add failing tests for 4-level RBAC role hierarchy`
  </action>
  <verify>
    <automated>npm test -- --testPathPattern="organizationMembers" 2>&1 | grep -E "FAIL|PASS|Tests:|failed"</automated>
  </verify>
  <done>Test file exists with all described test cases. Running tests shows FAIL (RED state). No implementation code written yet.</done>
</task>

<task type="tdd">
  <name>Task 2 (GREEN): Implement schema changes and role hierarchy logic</name>
  <files>
    backend/convex/schema.ts
    backend/convex/organizationMembers.ts
    backend/convex/migrations.ts
  </files>
  <action>
Write minimal implementation to make all RED tests pass.

**Step 1: Update schema.ts**

In `organizationMembers` table:
- Make existing `role` field optional: `role: convexVal.optional(convexVal.union(literal("owner"), literal("admin"), literal("member")))`
- Add new `userRole` field as optional: `userRole: convexVal.optional(convexVal.union(literal("admin"), literal("agent"), literal("collaborator"), literal("viewer")))`

In `invites` table:
- Make existing `role` field optional: same pattern as above
- Add `userRole` as optional with 4-level union

Add new `systemAdmins` table at end of schema:
```typescript
systemAdmins: defineTable({
  userId: convexVal.string(),
  createdAt: convexVal.number(),
}).index("by_user", ["userId"]),
```

Also add `by_workspace` index to `notifications` table (it's missing per research):
```typescript
.index("by_workspace", ["workspaceId"])
```

**Step 2: Update organizationMembers.ts**

Add at top of file (after imports):
```typescript
export const ROLE_LEVELS = {
  admin: 4,
  agent: 3,
  collaborator: 2,
  viewer: 1,
} as const;

export type UserRole = keyof typeof ROLE_LEVELS;

export function hasRequiredRole(userRole: UserRole, requiredRole: UserRole): boolean {
  return ROLE_LEVELS[userRole] >= ROLE_LEVELS[requiredRole];
}
```

Add `requireRole()` function (replaces requireAdmin/requireOwner — keep old ones for backward compat until Plan 03):
```typescript
export async function requireRole(
  ctx: any,
  workspaceId: Id<"workspaces">,
  userId: string,
  requiredRole: UserRole
): Promise<void> {
  // Check if system admin (bypasses workspace membership)
  const sysAdmin = await ctx.db
    .query("systemAdmins")
    .withIndex("by_user", (q: any) => q.eq("userId", userId))
    .first();
  if (sysAdmin) return;

  const member = await ctx.db
    .query("organizationMembers")
    .withIndex("by_workspace_user", (q: any) =>
      q.eq("workspaceId", workspaceId).eq("userId", userId)
    )
    .first();

  // Return 404 per locked decision (security through obscurity, not 403)
  if (!member) {
    throw new ConvexError("NOT_FOUND");
  }

  const effectiveRole = (member.userRole ?? mapLegacyRole(member.role)) as UserRole;
  if (!hasRequiredRole(effectiveRole, requiredRole)) {
    throw new ConvexError("NOT_FOUND");
  }
}

// Internal helper for legacy role mapping during migration window
function mapLegacyRole(role: string | undefined): UserRole {
  const mapping: Record<string, UserRole> = {
    owner: "admin",
    admin: "collaborator",
    member: "viewer",
  };
  return mapping[role ?? ""] ?? "viewer";
}
```

Update `removeMember()` — replace "last owner" check with "last admin" check:
- Check if member has `userRole === "admin"` (or legacy `role === "owner"`)
- Count admins: `.filter(m => m.userRole === "admin" || m.role === "owner")`
- Throw `ConvexError("Must have at least one admin")` if count <= 1

Update `hasAccess` query to use new 4-level roles in `requiredRole` union (keep backward compat):
```typescript
requiredRole: convexVal.optional(
  convexVal.union(
    convexVal.literal("admin"), convexVal.literal("agent"),
    convexVal.literal("collaborator"), convexVal.literal("viewer"),
    // Legacy compat during migration window:
    convexVal.literal("owner"), convexVal.literal("member")
  )
)
```

**Step 3: Add MIG-18 to migrations.ts**

Append at end of file:
```typescript
/**
 * MIG-18: Role Hierarchy Migration - Phase 2 (2026-02-27)
 *
 * Migrates organizationMembers.role (owner/admin/member) → userRole (admin/agent/collaborator/viewer)
 * - owner → admin
 * - admin → collaborator
 * - member → viewer
 *
 * Also migrates invites.role with same mapping.
 * Idempotent: skips records that already have userRole set.
 *
 * IMPORTANT: This mutation migrates ALL records in a single operation using .collect()
 * (no batchSize — locked decision: "immediate data migration in a single operation").
 * Convex mutations are limited to ~8MB document read/write budget. If organizationMembers
 * grows beyond ~50,000 rows, this single-pass approach may hit Convex's per-mutation limits.
 * At that scale, migrate in a separate task queue job. For Phase 2, single-pass is correct.
 */
export const migrationRoleHierarchy = mutation({
  args: {},
  handler: async (ctx) => {
    const roleMapping: Record<string, string> = {
      owner: "admin",
      admin: "collaborator",
      member: "viewer",
    };

    // Collect ALL records atomically — no batching, per locked decision
    const members = await ctx.db.query("organizationMembers").collect();
    let migrated = 0;

    for (const member of members) {
      if (!member.userRole && member.role) {
        const newRole = roleMapping[member.role] ?? "viewer";
        // Write userRole and clear legacy role field in the same patch
        await ctx.db.patch(member._id, { userRole: newRole, role: undefined });
        migrated++;
      }
    }

    const invites = await ctx.db.query("invites").collect();
    let invitesMigrated = 0;
    for (const invite of invites) {
      if (!invite.userRole && invite.role) {
        const newRole = roleMapping[invite.role] ?? "viewer";
        // Write userRole and clear legacy role field in the same patch
        await ctx.db.patch(invite._id, { userRole: newRole, role: undefined });
        invitesMigrated++;
      }
    }

    return {
      migrated,
      invitesMigrated,
      message: `MIG-18: Migrated ${migrated} members and ${invitesMigrated} invites to 4-level role hierarchy`,
    };
  },
});
```

**Step 4: Remove legacy `role` field from schema after migration**

After MIG-18 is in place and the migration has been run (verified by checking that no records have `role` set), update `schema.ts` to remove the `role` field entirely from both `organizationMembers` and `invites` tables:

```typescript
// organizationMembers — AFTER MIG-18:
organizationMembers: defineTable({
  workspaceId: convexVal.optional(convexVal.id("workspaces")),
  userId: convexVal.string(),
  // role field REMOVED — no longer present after MIG-18
  userRole: convexVal.union(
    convexVal.literal("admin"),
    convexVal.literal("agent"),
    convexVal.literal("collaborator"),
    convexVal.literal("viewer")
  ),
  // ... allBoardsRead, allBoardsWrite, etc.
})

// invites — AFTER MIG-18:
invites: defineTable({
  // role field REMOVED
  userRole: convexVal.union(
    convexVal.literal("admin"),
    convexVal.literal("agent"),
    convexVal.literal("collaborator"),
    convexVal.literal("viewer")
  ),
  // ...
})
```

IMPORTANT: Only make `userRole` required (not optional) after removing the legacy `role` field. During the initial schema step (Step 1 above), both fields are optional to allow the migration mutation to run. After MIG-18 is confirmed complete, remove `role` and make `userRole` required. This keeps the schema change atomic with the migration — no coexistence period per locked decision.

Run tests: `npm test -- --testPathPattern="organizationMembers"`

All tests MUST pass (GREEN). Commit: `feat(02-01): implement 4-level RBAC role hierarchy and MIG-18 migration`
  </action>
  <verify>
    <automated>npm test -- --testPathPattern="organizationMembers" 2>&1 | grep -E "PASS|Tests:|passed"</automated>
  </verify>
  <done>All organizationMembers tests pass (GREEN). schema.ts has userRole field + systemAdmins table + notifications by_workspace index. organizationMembers.ts exports ROLE_LEVELS, UserRole, hasRequiredRole, requireRole. migrations.ts has MIG-18 mutation.</done>
</task>

</tasks>

<verification>
Run targeted test suite:
```bash
npm test -- --testPathPattern="organizationMembers"
```
Expected: All tests PASS.

TypeScript check (schema validity):
```bash
npm run build 2>&1 | head -30
```
Expected: No TypeScript errors in schema.ts or organizationMembers.ts.
</verification>

<success_criteria>
- [ ] `ROLE_LEVELS` exported with admin=4, agent=3, collaborator=2, viewer=1
- [ ] `hasRequiredRole(admin, viewer)` returns true; `hasRequiredRole(viewer, admin)` returns false
- [ ] `requireRole()` throws ConvexError("NOT_FOUND") for missing member and insufficient role
- [ ] `requireRole()` passes silently for systemAdmins (no workspace membership needed)
- [ ] schema.ts initially has both `role` (optional legacy) and `userRole` (optional new) to allow MIG-18 to run
- [ ] After MIG-18: legacy `role` field removed from organizationMembers and invites tables; `userRole` becomes required
- [ ] schema.ts has `systemAdmins` table with `by_user` index
- [ ] schema.ts has `by_workspace` index on notifications table
- [ ] `invites` table schema updated with optional `userRole`
- [ ] MIG-18 mutation in migrations.ts maps owner→admin, admin→collaborator, member→viewer
- [ ] `removeMember` throws "Must have at least one admin" when removing last admin
- [ ] All tests pass: `npm test -- --testPathPattern="organizationMembers"`
</success_criteria>

<output>
After completion, create `.planning/phases/02-workspace-isolation-rbac/02-01-SUMMARY.md` with:
- What was built (ROLE_LEVELS, requireRole, MIG-18, schema changes)
- Key exported types/functions for downstream plans
- Any deviations from plan
</output>
