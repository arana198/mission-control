---
phase: 02-workspace-isolation-rbac
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - backend/convex/utils/workspaceAuth.ts
  - backend/convex/utils/__tests__/workspaceAuth.test.ts
  - backend/convex/functions.ts
  - backend/convex/__tests__/functions.test.ts
autonomous: true
requirements:
  - WS-02
  - WS-05

must_haves:
  truths:
    - "Role hierarchy correctly orders admin > agent > collaborator > viewer"
    - "hasMinimumRole returns correct boolean for all role combinations"
    - "workspaceQuery builder requires workspaceId and verifies workspace exists"
    - "workspaceMutation builder requires workspaceId and verifies workspace exists"
    - "adminMutation builder rejects users without admin role in target workspace"
    - "workspaceQuery injects workspaceId into ctx for handler to use"
  artifacts:
    - path: "backend/convex/utils/workspaceAuth.ts"
      provides: "Pure RBAC logic: role hierarchy, permission checks, role constants"
      exports: ["ROLES", "WorkspaceRole", "ROLE_HIERARCHY", "hasMinimumRole", "canManageWorkspace", "canWriteData", "canReadData"]
    - path: "backend/convex/utils/__tests__/workspaceAuth.test.ts"
      provides: "Unit tests for RBAC pure logic"
      min_lines: 80
    - path: "backend/convex/functions.ts"
      provides: "workspaceQuery, workspaceMutation, adminMutation builders"
      exports: ["workspaceQuery", "workspaceMutation", "adminMutation"]
    - path: "backend/convex/__tests__/functions.test.ts"
      provides: "Unit tests for custom function builders"
      min_lines: 100
  key_links:
    - from: "backend/convex/functions.ts"
      to: "backend/convex/utils/workspaceAuth.ts"
      via: "imports ROLE_HIERARCHY for admin check"
      pattern: "import.*workspaceAuth"
    - from: "backend/convex/functions.ts"
      to: "convex-helpers/server/customFunctions"
      via: "customQuery, customMutation builders"
      pattern: "import.*customQuery.*customMutation.*convex-helpers"
---

<objective>
Create the RBAC pure logic layer and workspace-scoped Convex function builders that form the foundation for all workspace isolation enforcement.

Purpose: Every workspace-scoped query and mutation in the codebase will be migrated to use these builders. They enforce membership checks structurally (impossible to forget) rather than manually (easy to forget). This is the foundational layer for WS-02 (data isolation) and WS-05 (user sees only assigned workspaces).

Output: Two tested modules -- `workspaceAuth.ts` (pure role logic) and `functions.ts` (Convex custom function builders wrapping `convex-helpers`).
</objective>

<execution_context>
@/Users/arana/.claude/get-shit-done/workflows/execute-plan.md
@/Users/arana/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-workspace-isolation-rbac/02-RESEARCH.md

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->

From backend/convex/organizationMembers.ts:
```typescript
// Existing role union in schema
role: convexVal.union(
  convexVal.literal("owner"),
  convexVal.literal("admin"),
  convexVal.literal("member")
)

// Existing helper
export async function requireAdmin(
  ctx: any,
  workspaceId: Id<"workspaces">,
  userId: string
): Promise<void>
```

From backend/convex/schema.ts (organizationMembers):
```typescript
organizationMembers: defineTable({
  workspaceId: convexVal.optional(convexVal.id("workspaces")),
  userId: convexVal.string(),
  userEmail: convexVal.optional(convexVal.string()),
  userName: convexVal.optional(convexVal.string()),
  role: convexVal.union(
    convexVal.literal("owner"),
    convexVal.literal("admin"),
    convexVal.literal("member")
  ),
  allBoardsRead: convexVal.boolean(),
  allBoardsWrite: convexVal.boolean(),
  createdAt: convexVal.number(),
  updatedAt: convexVal.number(),
})
  .index("by_workspace", ["workspaceId"])
  .index("by_user", ["userId"])
  .index("by_workspace_user", ["workspaceId", "userId"])
```

From backend/convex/_generated/server.ts:
```typescript
import { query, mutation } from "./_generated/server";
// These are the raw Convex function builders that workspaceQuery/workspaceMutation will wrap
```

convex-helpers API (to be installed):
```typescript
import { customQuery, customMutation, customCtx } from "convex-helpers/server/customFunctions";
// customQuery(baseQuery, { args, input }) => enhanced query builder
// customMutation(baseMutation, { args, input }) => enhanced mutation builder
// input: async (ctx, extractedArgs) => { ctx: additionalCtx, args: remainingArgs }
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install convex-helpers and create RBAC pure logic with TDD</name>
  <files>
    backend/package.json
    backend/convex/utils/workspaceAuth.ts
    backend/convex/utils/__tests__/workspaceAuth.test.ts
  </files>
  <action>
**Step 1: Install convex-helpers**
```bash
cd backend && npm install convex-helpers
```

**Step 2: RED -- Write failing tests for workspaceAuth.ts**

Create `backend/convex/utils/__tests__/workspaceAuth.test.ts` with tests for:

1. **Role constants:** Verify `ROLES` object has `admin`, `agent`, `collaborator`, `viewer` keys
2. **Role hierarchy:** Verify `ROLE_HIERARCHY` assigns admin=4, agent=3, collaborator=2, viewer=1
3. **hasMinimumRole:**
   - admin has minimum of admin → true
   - admin has minimum of viewer → true
   - viewer has minimum of admin → false
   - agent has minimum of collaborator → true
   - collaborator has minimum of agent → false
4. **canManageWorkspace:** Only admin returns true; agent, collaborator, viewer return false
5. **canWriteData:** admin and agent and collaborator return true; viewer returns false
6. **canReadData:** All roles return true (viewer is minimum)
7. **Edge case:** Handle "owner" legacy role by mapping it to admin level in comments (not in hierarchy -- migration handles this)

Run tests -- they must FAIL (RED).

**Step 3: GREEN -- Implement workspaceAuth.ts**

Create `backend/convex/utils/workspaceAuth.ts` with:

```typescript
/**
 * Pure RBAC Logic for Workspace Authorization
 * Zero Convex dependencies. All functions are deterministic and testable in isolation.
 */

export const ROLES = {
  ADMIN: "admin",
  AGENT: "agent",
  COLLABORATOR: "collaborator",
  VIEWER: "viewer",
} as const;

export type WorkspaceRole = (typeof ROLES)[keyof typeof ROLES];

export const ROLE_HIERARCHY: Record<WorkspaceRole, number> = {
  admin: 4,
  agent: 3,
  collaborator: 2,
  viewer: 1,
};

export function hasMinimumRole(userRole: WorkspaceRole, requiredRole: WorkspaceRole): boolean {
  return ROLE_HIERARCHY[userRole] >= ROLE_HIERARCHY[requiredRole];
}

export function canManageWorkspace(role: WorkspaceRole): boolean {
  return hasMinimumRole(role, "admin");
}

export function canWriteData(role: WorkspaceRole): boolean {
  return hasMinimumRole(role, "collaborator");
}

export function canReadData(role: WorkspaceRole): boolean {
  return hasMinimumRole(role, "viewer");
}
```

Run tests -- they must PASS (GREEN).

**IMPORTANT:** This module has ZERO Convex dependencies. It is pure TypeScript logic. Do NOT import anything from `convex/` or `_generated/`.
  </action>
  <verify>
    <automated>cd /Users/arana/dev/ankit/mission-control && npm test -- --testPathPattern=workspaceAuth</automated>
  </verify>
  <done>
    - workspaceAuth.ts exists with 4 exported constants/types and 3 exported functions
    - All tests pass: role hierarchy, hasMinimumRole for all combinations, canManageWorkspace, canWriteData, canReadData
    - Zero Convex dependencies in workspaceAuth.ts
  </done>
</task>

<task type="auto">
  <name>Task 2: Create workspace-scoped Convex function builders with TDD</name>
  <files>
    backend/convex/functions.ts
    backend/convex/__tests__/functions.test.ts
  </files>
  <action>
**Step 1: RED -- Write failing tests for functions.ts**

Create `backend/convex/__tests__/functions.test.ts`.

Since `workspaceQuery`, `workspaceMutation`, and `adminMutation` use `customQuery`/`customMutation` from `convex-helpers` which depend on the Convex runtime, the tests need to mock the Convex layer. Test the builder **input functions** in isolation:

Mock `convex-helpers/server/customFunctions` to capture the `input` function and test it directly:

1. **workspaceQuery builder input:**
   - Given valid workspaceId → ctx.db.get returns workspace → input returns `{ ctx: { workspace, workspaceId }, args: {} }`
   - Given invalid workspaceId → ctx.db.get returns null → input throws "Workspace not found"

2. **workspaceMutation builder input:**
   - Same as workspaceQuery but for mutations

3. **adminMutation builder input:**
   - Given valid workspaceId + userId with admin role → input returns `{ ctx: { workspace, workspaceId, member }, args: {} }`
   - Given valid workspaceId + userId with member role → input throws "Admin access required"
   - Given valid workspaceId + userId not a member → input throws (membership not found)
   - Given valid workspaceId + userId with owner role (legacy) → input succeeds (owner >= admin)

**Testing approach:** Extract the `input` function from the builder config object. The builder is just `customQuery(query, config)` -- mock `customQuery` to capture `config`, then test `config.input(mockCtx, args)` directly. This avoids needing the Convex runtime.

```typescript
// Mock pattern:
let capturedConfig: any;
jest.mock("convex-helpers/server/customFunctions", () => ({
  customQuery: (_base: any, config: any) => {
    capturedConfig = config;
    return jest.fn(); // Return dummy -- we test the input function, not the full builder
  },
  customMutation: (_base: any, config: any) => {
    capturedConfig = config;
    return jest.fn();
  },
}));
```

Run tests -- they must FAIL (RED).

**Step 2: GREEN -- Implement functions.ts**

Create `backend/convex/functions.ts`:

```typescript
/**
 * Workspace-Scoped Convex Function Builders
 *
 * Use these instead of raw `query`/`mutation` from _generated/server.
 * They enforce workspace membership checks structurally.
 *
 * Usage:
 *   import { workspaceQuery, workspaceMutation, adminMutation } from "./functions";
 *
 *   export const myQuery = workspaceQuery({
 *     args: { /* your args */ },
 *     handler: async (ctx, args) => {
 *       // ctx.workspaceId and ctx.workspace are injected and verified
 *       return ctx.db.query("tasks")
 *         .withIndex("by_workspace", q => q.eq("workspaceId", ctx.workspaceId))
 *         .collect();
 *     },
 *   });
 */

import { customQuery, customMutation } from "convex-helpers/server/customFunctions";
import { query, mutation } from "./_generated/server";
import { v } from "convex/values";
import { ROLE_HIERARCHY, type WorkspaceRole } from "./utils/workspaceAuth";

// workspaceQuery: requires workspaceId, verifies workspace exists
export const workspaceQuery = customQuery(query, {
  args: { workspaceId: v.id("workspaces") },
  input: async (ctx, { workspaceId }) => {
    const workspace = await ctx.db.get(workspaceId);
    if (!workspace) throw new Error("Workspace not found");
    return { ctx: { workspace, workspaceId }, args: {} };
  },
});

// workspaceMutation: requires workspaceId, verifies workspace exists
export const workspaceMutation = customMutation(mutation, {
  args: { workspaceId: v.id("workspaces") },
  input: async (ctx, { workspaceId }) => {
    const workspace = await ctx.db.get(workspaceId);
    if (!workspace) throw new Error("Workspace not found");
    return { ctx: { workspace, workspaceId }, args: {} };
  },
});

// adminMutation: requires workspaceId + userId, verifies admin+ membership
export const adminMutation = customMutation(mutation, {
  args: {
    workspaceId: v.id("workspaces"),
    userId: v.string(),
  },
  input: async (ctx, { workspaceId, userId }) => {
    const workspace = await ctx.db.get(workspaceId);
    if (!workspace) throw new Error("Workspace not found");
    const member = await ctx.db
      .query("organizationMembers")
      .withIndex("by_workspace_user", (q: any) =>
        q.eq("workspaceId", workspaceId).eq("userId", userId)
      )
      .first();
    if (!member) throw new Error("User is not a member of this workspace");
    // Accept "owner" (legacy) and "admin" as admin-level
    const role = member.role as string;
    const roleLevel = role === "owner" ? 4 : (ROLE_HIERARCHY[role as WorkspaceRole] ?? 0);
    if (roleLevel < ROLE_HIERARCHY.admin) {
      throw new Error("Admin access required");
    }
    return { ctx: { workspace, workspaceId, member }, args: {} };
  },
});
```

Run tests -- they must PASS (GREEN).

**IMPORTANT:** The `convex-helpers` `customQuery`/`customMutation` API wraps the base query/mutation with additional args and an `input` function that runs before the handler. The `input` function receives `(ctx, extractedArgs)` and returns `{ ctx: additionalCtx, args: remainingArgs }`. The additional ctx properties are merged into the handler's ctx.
  </action>
  <verify>
    <automated>cd /Users/arana/dev/ankit/mission-control && npm test -- --testPathPattern=functions.test</automated>
  </verify>
  <done>
    - functions.ts exists with 3 exported builders: workspaceQuery, workspaceMutation, adminMutation
    - All tests pass: workspace verification, membership check, role level enforcement, legacy owner handling
    - convex-helpers installed in backend/package.json
    - Builders import ROLE_HIERARCHY from workspaceAuth.ts (key link verified)
  </done>
</task>

</tasks>

<verification>
```bash
# All RBAC + builder tests pass
cd /Users/arana/dev/ankit/mission-control && npm test -- --testPathPattern="workspaceAuth|functions.test"

# TypeScript compiles
cd /Users/arana/dev/ankit/mission-control && npm run build

# convex-helpers is installed
grep "convex-helpers" backend/package.json
```
</verification>

<success_criteria>
- workspaceAuth.ts: Pure RBAC logic with 4-role hierarchy (admin > agent > collaborator > viewer)
- functions.ts: Three workspace-scoped builders wrapping convex-helpers
- All unit tests pass (RED → GREEN verified)
- convex-helpers installed as dependency
- TypeScript compiles cleanly
- Zero runtime errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-workspace-isolation-rbac/02-01-SUMMARY.md`
</output>
