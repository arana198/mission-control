import { v as convexVal } from "convex/values";
import { query, mutation } from "./_generated/server";

/**
 * Agent Management
 * CRUD operations for the 10-agent squad
 */

// Get all agents with their current status
export const getAllAgents = query({
  handler: async (ctx) => {
    const agents = await ctx.db.query("agents").collect();
    return agents;
  },
});

// Get single agent by ID
export const getAgentById = query({
  args: { agentId: convexVal.id("agents") },
  handler: async (ctx, { agentId }) => {
    return await ctx.db.get(agentId);
  },
});

// Get agent by name (case-insensitive)
export const getByName = query({
  args: { name: convexVal.string() },
  handler: async (ctx, { name }) => {
    // Try lowercase first (agents query with lowercase names)
    const lowerName = name.toLowerCase();
    const agent = await ctx.db
      .query("agents")
      .withIndex("by_name", (q) => q.eq("name", lowerName))
      .first();
    if (agent) return agent;
    
    // Fallback: try exact match (for legacy capitalized names)
    return await ctx.db
      .query("agents")
      .withIndex("by_name", (q) => q.eq("name", name))
      .first();
  },
});

// Update agent status
export const updateStatus = mutation({
  args: {
    businessId: convexVal.id("businesses"),
    agentId: convexVal.id("agents"),
    status: convexVal.union(convexVal.literal("idle"), convexVal.literal("active"), convexVal.literal("blocked")),
    currentTaskId: convexVal.optional(convexVal.id("tasks")),
  },
  handler: async (ctx, { businessId, agentId, status, currentTaskId }) => {
    const agent = await ctx.db.get(agentId);
    if (!agent) throw new Error("Agent not found");

    await ctx.db.patch(agentId, {
      status,
      currentTaskId,
      lastHeartbeat: Date.now(),
    });

    // Log activity
    await ctx.db.insert("activities", {
      businessId,
      type: "agent_status_changed",
      agentId,
      agentName: agent.name,
      message: `${agent.name} is now ${status}`,
      taskId: currentTaskId,
      createdAt: Date.now(),
    });

    return { success: true };
  },
});

// Heartbeat ping from agent
export const heartbeat = mutation({
  args: {
    agentId: convexVal.id("agents"),
    currentTaskId: convexVal.optional(convexVal.id("tasks")),
  },
  handler: async (ctx, { agentId, currentTaskId }) => {
    const agent = await ctx.db.get(agentId);
    if (!agent) throw new Error("Agent not found");

    await ctx.db.patch(agentId, {
      lastHeartbeat: Date.now(),
      currentTaskId,
    });

    return { success: true, timestamp: Date.now() };
  },
});

// Get agent with current task details
export const getWithCurrentTask = query({
  args: { agentId: convexVal.id("agents") },
  handler: async (ctx, { agentId }) => {
    const agent = await ctx.db.get(agentId);
    if (!agent) return null;

    let currentTask = null;
    if (agent.currentTaskId) {
      currentTask = await ctx.db.get(agent.currentTaskId);
    }

    return { ...agent, currentTask };
  },
});

// Update agent name (for lowercase migration)
export const updateName = mutation({
  args: {
    id: convexVal.id("agents"),
    name: convexVal.string(),
  },
  handler: async (ctx, { id, name }) => {
    await ctx.db.patch(id, { name });
    return { success: true, id, name };
  },
});

// Lowercase all agent names (one-time migration)
export const lowercaseAllNames = mutation({
  args: {},
  handler: async (ctx) => {
    const agents = await ctx.db.query("agents").collect();
    let updated = 0;
    for (const agent of agents) {
      const lowerName = agent.name.toLowerCase();
      if (agent.name !== lowerName) {
        await ctx.db.patch(agent._id, { name: lowerName });
        updated++;
      }
    }
    return { updated, total: agents.length };
  },
});

/**
 * Agent self-registration via HTTP API
 * Creates a new agent or returns existing agent with API key
 */
export const register = mutation({
  args: {
    name: convexVal.string(),
    role: convexVal.string(),
    level: convexVal.union(convexVal.literal("lead"), convexVal.literal("specialist"), convexVal.literal("intern")),
    sessionKey: convexVal.string(),
    capabilities: convexVal.optional(convexVal.array(convexVal.string())),
    model: convexVal.optional(convexVal.string()),
    personality: convexVal.optional(convexVal.string()),
    workspacePath: convexVal.string(),  // Agent's workspace directory (required)
    generatedApiKey: convexVal.string(),  // Generated by route layer
  },
  handler: async (ctx, args) => {
    // Lowercase name for consistent lookups
    const lowerName = args.name.toLowerCase();

    // Check if agent already exists
    const existing = await ctx.db
      .query("agents")
      .withIndex("by_name", (q) => q.eq("name", lowerName))
      .first();

    if (existing) {
      // Agent exists — return existing (or assign key/workspace path if missing)
      let apiKey = existing.apiKey;
      const updates: any = {};

      if (!apiKey) {
        // Legacy agent without key — assign new one
        apiKey = args.generatedApiKey;
        updates.apiKey = apiKey;
      }

      if (!existing.workspacePath && args.workspacePath) {
        // Update workspace path for legacy agents
        updates.workspacePath = args.workspacePath;
      }

      if (Object.keys(updates).length > 0) {
        await ctx.db.patch(existing._id, updates);
      }

      return { agentId: existing._id, apiKey, isNew: false };
    }

    // New agent — create with apiKey
    const agentId = await ctx.db.insert("agents", {
      name: lowerName,
      role: args.role,
      level: args.level,
      status: "idle",
      sessionKey: args.sessionKey,
      lastHeartbeat: Date.now(),
      apiKey: args.generatedApiKey,
      capabilities: args.capabilities,
      model: args.model,
      personality: args.personality,
      workspacePath: args.workspacePath,
    });

    // Note: Agent registration is a global event, not business-specific, so we don't log activity
    // Activities are always scoped to a business, but agent registration spans all businesses

    return { agentId, apiKey: args.generatedApiKey, isNew: true };
  },
});

/**
 * Verify agent credentials (used by all agent API routes)
 */
export const verifyKey = query({
  args: {
    agentId: convexVal.id("agents"),
    apiKey: convexVal.string(),
  },
  handler: async (ctx, { agentId, apiKey }) => {
    const agent = await ctx.db.get(agentId);
    if (!agent) return null;
    if (!agent.apiKey || agent.apiKey !== apiKey) return null;
    return agent;
  },
});

/**
 * Update agent details (self-service by agent)
 * Agent authenticates with their apiKey and can update their own details
 */
export const updateDetails = mutation({
  args: {
    agentId: convexVal.id("agents"),
    apiKey: convexVal.string(),
    workspacePath: convexVal.optional(convexVal.string()),
    model: convexVal.optional(convexVal.string()),
    personality: convexVal.optional(convexVal.string()),
    capabilities: convexVal.optional(convexVal.array(convexVal.string())),
  },
  handler: async (ctx, { agentId, apiKey, workspacePath, model, personality, capabilities }) => {
    // Verify agent credentials
    const agent = await ctx.db.get(agentId);
    if (!agent) throw new Error("Agent not found");
    if (!agent.apiKey || agent.apiKey !== apiKey) {
      throw new Error("Invalid credentials");
    }

    // Build update object with only provided fields
    const updates: any = {};
    if (workspacePath !== undefined) updates.workspacePath = workspacePath;
    if (model !== undefined) updates.model = model;
    if (personality !== undefined) updates.personality = personality;
    if (capabilities !== undefined) updates.capabilities = capabilities;

    // If no fields to update, return current state
    if (Object.keys(updates).length === 0) {
      return { success: true, agent, updated: false };
    }

    // Update agent
    await ctx.db.patch(agentId, updates);

    // Get updated agent
    const updatedAgent = await ctx.db.get(agentId);

    return {
      success: true,
      agent: updatedAgent,
      updated: true,
      updatedFields: Object.keys(updates),
    };
  },
});
